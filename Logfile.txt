**********************                    12.02.2013********************************************                    26.12.2011GIT**********************                    16.09.2011l 4188: Bedingung Daten <>0 auskommentiert: senden auf jeden Fall, fuer Fehleruebertragung********************************************                    09.09.2011ERR_BIT SPI_ERR_BIT SPI_ERRBIT ordnen//SPI_ERRBIT     7  l 174 in TWI-Abfragen verwendetSPI_ERR_BIT    6  l 145 in SPI-Abfrage l 1680 verwendet//ERR_BIT        7  l 146 in SPI-Abfrage l 168 zweimal verwendetBits von spistatusSPI_SHIFT_IN_OK_BIT  6in SPI-Slave:ACTIVE_BIT           0STARTDATEN_BIT       1ENDDATEN_BIT         2SUCCESS_BIT          3LB_BIT               4HB_BIT               5SPI_ERR_BIT          6TWI_ERR_BIT          7********************************************                    24.04.2011SYNC_NEW eingefuehrt: TWI soll noch keine Daten uebertragenl 2235: SYNC_NULL in Startbedingung fuer Synchronisation eingefuehrt. Sync soll sofort starten.Startet sync sofort nach reset********************************************                    23.04.2011********************************************                    18.04.2011read Zeit richtigread Datum eingefuehrt********************************************                    17.04.2011********************************************                    15.04.2011********************************************                    07.04.2011TWBR wieder auf 72 gestellt (war 96)********************************************                    13.03.2011********************************************                    07.03.2011********************************************                    05.03.2011********************************************                    03.03.2011Echo von Heizung weiterleiten an Webserver outbuffer Byte 29********************************************                    25.02.2011l 3021: WoZiDaten zu outbuffer[30] addiert********************************************                    03.02.2011********************************************                    23.01.2011TWI_Master l 1900:case DATATASK anstelle von default********************************************                    19.01.2011********************************************                    10.01.2011l 1640ffSTATUSCONFIRMTASK eingefuegt: Statusaenderung erst bestaetigen, wenn bei Master angekommen********************************************                    18.12.2010********************************************                    15.12.2010Von TWI_Master644210_A_81_exp4********************************************                    09.12.2010********************************************                    03.12.2010********************************************                    01.12.2010Uhr lesen ausserhalb (if Lesestatus) -Schleife********************************************                    29.11.2010l 1658: else //if (in_hbdaten & (0x00)) if auskommentiert: Stoppt TWI sofort********************************************                    26.11.2010TWBR 96********************************************                    24.11.2010l 1217: spistatus & (1<<SPI_SHIFT_IN_OK_BIT); eingesetzt zum Starten des TWI********************************************                    15.11.2010TWBR = 80********************************************                    07.11.2010********************************************                    03.11.2010Server 210Vor jedem TWI-Aufruf delay_ms(2); eingefuegtl 1388: loopCounterSPI eingefuegttwimaster l263  in i2c_stop while {TWINT} auskommentiertTWBR=40 (war 200)********************************************                    01.11.2010l 1864: loopCounterTWI eingefuegtOSZIALO/HI fuer TWI-Dauer********************************************                    28.10.2010********************************************                    23.10.2010********************************************                    05.10.2010i2c_debloc eingefŸhrt: neun Takte auf SCL geben, um Slave zum Loslassen von SDA zu bewegen********************************************                    23.09.2010********************************************                    04.08.2010Takt 8 MHz********************************************                    03.08.2010SPI-Slave installieren********************************************                    19.07.2010********************************************                    18.07.2010l 3392: BUS_Status & (1<<TWI_CONTROLBIT), (1<<WEB_CONTROLBIT) aus Statustask entferntl 3400: Ruecksetzen von Statusbit wieder eingefŸgt********************************************                    08.07.2010l 597: ISR: (spistatus&(1<<TWI_STATUSBIT)) in Abfrage einbezogen********************************************                    05.07.2010l 3357 BUS_Status &=~(1<<TWI_CONTROLBIT); geloeschtl 1541: spistatus &= ~(1<<SPI_SENDBIT); vor if schreibstatus verschobenl 3515: shift nur wenn sendbit und kein errbitl 3419: BUS_Status |=(1<<TWI_CONTROLBIT);		// TWI wieder ON	 geloescht, in Statustask-Abrage veschoben********************************************                    03.07.2010Statustask abfragen, bei Status 0 timer0 deaktivieren: Keine Stoerungen duch SPI-Aufrufe des Timers********************************************                    30.06.2010********************************************                    27.06.2010Daten von Estrich auch am Anfang von outbuffer eingesetzt********************************************TWI_Master32_90_SR_16 Version: SR_1626.03.2010**21.3.10DATATASK auf C0 gesetzt(WebTxStartDaten >= DATATASK) anstatt ==, Vorbereitung fuer unterscheiden von SOLARTASK und DATATASK**5.2.10BUS_Status |=(1<<TWI_CONTROLBIT); Kontrollieren, wie TWI wieder eingeschaltet wirdLinie 1600Timer fuer TWI zuruecksetzen fuer EEPROMWRITETASKTest: BUS_Status |=(1<<TWI_CONTROLBIT); in ISR: eventuell zu frueh. 		in Talk() und Listen():// Timer fuer TWI-Schlaufe zuruecksetzen		TCNT0 = 0x00;		SIGNAL_Count=0;***10.12.09setReadyToSend von Bedingung Daten[2,3,4] nicht Null abhŠngig gemacht25.10.09count durch SIGNAL__count ersetzt2.2.09line 2215EingefŸgt: i2c_stop();TWI zutuecksetzen;TWBR =0;delay_ms(10);//	TWI neu starteni2c_init();1.2.line 873Anfangswert von startdelay in ODER eingefuegt: Kontrolle laeft auch sostartdelay == Pins fuer TWI zuerst als Ausgaenge und HIErst nach Ablauf Startdelay zu Eingaengen gemachtline 1046i2c_stop eingefuegtline 1424Ende von if (DCF77-erfolg==0) nach 2144 verschoben: Abfrage der Slaves nur wenn Uhr gelesen werden kannline 916TWBR =0; ersetzt durchTWCR =0;Quelle: file:///Users/sysadmin/Documents/Elektronik/AVR/I2C/TWI-Error/TWI%20-%20AVR%20stŸrzt%20ab%20-%20mikrocontroller.net.webarchiveBUS_Status:31.1.09line 2070 i2c_stop() eingesetztTWI_Master32_90_SR_16*************26.03.2010